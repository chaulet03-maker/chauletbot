import asyncio, json, traceback, math, os, os
from datetime import datetime, timezone
import pandas as pd
from bot.settings import MODE, SYMBOLS, TIMEFRAME, LOOP_SECONDS, RISK, LEV, ORDER, FILTERS, INDICATORS, STRAT, REGIME, TELEGRAM_NOTIFY_ERRORS, FEES, FUNDING
from bot.logger import BOT_LOGGER, decision_event, log_exception
from bot.core.indicators import add_indicators
from bot.core.strategy import generate_signal
from bot.core.regime import classify
from bot.core.risk import dynamic_leverage_from_regime, position_size, BudgetManager
from bot.exchanges.binance_client import build_exchange, fetch_ohlcv_df, fetch_orderbook_stats, PaperExchange
from bot.execution.trader import Trader
from bot.storage.csv_store import append_csv
from bot.utils.time_utils import now_utc, to_iso
from bot.telemetry.telegram_bot import build_app, notify, notify
from bot.telemetry.formatter import open_msg
from bot.telemetry.webhooks import post_event
from bot.state import load_state, save_state, read_and_clear_cmds

DATA_POS = "data/positions.json"
DATA_MKT = "data/market_snapshot.json"
DATA_DIAG = "data/diag.json"

def _write_json(path, payload):
    with open(path,"w",encoding="utf-8") as f:
        json.dump(payload,f,ensure_ascii=False,indent=2)

def _append_diag(sym, reason):
    try:
        d = {}
        try:
            with open(DATA_DIAG,"r",encoding="utf-8") as f: d=json.load(f)
        except Exception: d={}
        d.setdefault(sym, []).append(reason)
        _write_json(DATA_DIAG, d)
    except Exception:
        pass

async def trade_symbol(app, trader: Trader, exchange, symbol: str, allow_new_entries: bool, budget: BudgetManager):
    # OHLCV
    try:
        tf = "1m" if TIMEFRAME=="2m" else TIMEFRAME
        limit = 600 if tf=="1m" else 300
        df = fetch_ohlcv_df(exchange, symbol, tf, limit=limit)
        if TIMEFRAME=="2m":
            df = (df.set_index("timestamp").resample("2T").agg({"open":"first","high":"max","low":"min","close":"last","volume":"sum"}).dropna().reset_index())
    except Exception as e:
        decision_event("API_ERROR", f"OHLCV fail {symbol}: {e}")
        _append_diag(symbol, f"API_ERROR OHLCV {e}")
        return

    if len(df)<50:
        decision_event("DATA_TOO_SHORT", f"Pocas velas {symbol}")
        _append_diag(symbol, "DATA_TOO_SHORT")
        return

    # Indicadores y r√©gimen
    try:
        dfi = add_indicators(df, INDICATORS | {"atr_period": FILTERS.get("atr_period",14)})
    except Exception as e:
        decision_event("INDICATOR_ERROR", f"Indicadores fail {symbol}: {e}")
        _append_diag(symbol, "INDICATOR_ERROR")
        return
    if dfi.empty:
        _append_diag(symbol, "DATA_EMPTY")
        return

    row = dfi.iloc[-1]
    price = float(row.close)
    atr = float(row.atr)

    # Market snapshot
    snap = {}
    try:
        try:
            with open(DATA_MKT,"r",encoding="utf-8") as f: snap = json.load(f)
        except Exception: snap = {}
        snap[symbol] = {"last_close": price, "ts": to_iso(now_utc())}
        _write_json(DATA_MKT, snap)
    except Exception as e:
        log_exception(BOT_LOGGER,"snapshot error", err=str(e))

    # Microestructura
    try:
        ob = fetch_orderbook_stats(exchange, symbol, depth=5)
    except Exception as e:
        decision_event("API_ERROR", f"Orderbook fail {symbol}: {e}")
        _append_diag(symbol, f"API_ERROR OB {e}")
        return
    if ob["liq_usdt"] < float(FILTERS.get("min_orderbook_liquidity_usdt",600000)):
        decision_event("LIQUIDITY_LOW", f"{symbol} liquidez insuficiente", **ob)
        _append_diag(symbol, "LIQUIDITY_LOW")
        return
    if ob["spread_bps"] is not None and ob["spread_bps"] > float(FILTERS.get("max_spread_bps",5)):
        decision_event("SPREAD_WIDE", f"{symbol} spread {ob['spread_bps']:.2f} bps")
        _append_diag(symbol, "SPREAD_WIDE")
        return

    # Circuit breakers
    paused, why = budget.circuit_breakers()
    if paused:
        decision_event("CIRCUIT_PAUSE", f"{symbol} {why}")
        _append_diag(symbol, why)
        return

    # Lateral / filtros
    if row.adx < float(FILTERS.get("adx_threshold",15)) or row.bb_width_bps < float(FILTERS.get("bb_width_min_bps",12)):
        decision_event("SIDEWAYS_FILTER", f"{symbol} lateral", adx=float(row.adx), bb=float(row.bb_width_bps))
        _append_diag(symbol, "SIDEWAYS_FILTER")
        can_open = False
    else:
        can_open = True

    # Se√±al
    sig = generate_signal(dfi, STRAT, FILTERS)

    # Permisos
    if not allow_new_entries:
        decision_event("BOT_PAUSED", f"{symbol} nuevas entradas deshabilitadas")
        _append_diag(symbol, "BOT_PAUSED")
        return
    if sig.side=="flat":
        decision_event("SIGNAL_WEAK", f"{symbol} se√±al insuficiente", conf=float(sig.confidence))
        _append_diag(symbol, f"SIGNAL_WEAK conf={sig.confidence:.2f}")
        return
    if not can_open:
        _append_diag(symbol, "FILTER_BLOCK")
        return

    # Regime -> lev
    regime = classify(row, REGIME)
    lev = dynamic_leverage_from_regime(regime.name, int(LEV.get("min",5)), int(LEV.get("max",15)))

    # Tama√±o por R + m√≠nimos
    qty, notional, margin = position_size(trader.equity(), price, atr,
                                          float(RISK.get("risk_per_trade",0.01)),
                                          float(STRAT.get("stop_atr_mult",2.0)),
                                          float(RISK.get("min_notional_usdt",100)),
                                          float(RISK.get("min_margin_usdt",20)),
                                          lev)
    if qty<=0 or notional<=0:
        decision_event("RISK_REJECTED", f"{symbol} qty/notional inv√°lido", qty=qty, notional=notional, margin=margin, lev=lev)
        _append_diag(symbol, f"RISK_REJECTED qty={qty:.6f} notional={notional:.2f}")
        return

    # Abrir
    ok, latency, notional2 = trader.open(symbol, sig.side, qty, price, atr, lev)
    if ok:
        sl = (price - float(STRAT.get("stop_atr_mult",2.0))*atr) if sig.side=="long" else (price + float(STRAT.get("stop_atr_mult",2.0))*atr)
        tp1 = price + (float(STRAT.get("tp1_R",1.0))*atr if sig.side=="long" else -float(STRAT.get("tp1_R",1.0))*atr)
        tp2 = price + (float(STRAT.get("tp2_R",2.0))*atr if sig.side=="long" else -float(STRAT.get("tp2_R",2.0))*atr)
        msg = open_msg(symbol, sig.side, margin, lev, notional2, price, tp1, tp2, sl, ORDER.get("order_type","market"), latency)
        if app: await notify(app, msg)
        post_event({"type":"open","symbol":symbol,"side":sig.side,"qty":qty,"price":price,"lev":lev,"notional":notional2})

async def process_commands(trader: Trader, app, exchange):
    from bot.state import load_state, save_state, read_and_clear_cmds
    cmds = read_and_clear_cmds()
    if not cmds: return
    st = load_state()
    for cmd in cmds:
        t = cmd.get("type")
        if t == "bot_on":
            st["allow_new_entries"] = True
            if app: await notify(app, "‚úÖ Bot ON")
        elif t == "bot_off":
            st["allow_new_entries"] = False
            if app: await notify(app, "‚è∏Ô∏è Bot OFF")
        elif t == "close_all":
            for sym in list(trader.positions.keys()):
                price = exchange.fetch_ticker(sym)["last"] if hasattr(exchange,"fetch_ticker") else None
                price = price or 0.0
                trader.close_symbol(sym, price, label="CLOSE_CMD_ALL")
            if app: await notify(app, "Cierre de todas las posiciones enviado.")
        elif t == "close_symbol":
            sym = cmd.get("symbol")
            if sym:
                price = exchange.fetch_ticker(sym)["last"] if hasattr(exchange,"fetch_ticker") else None
                price = price or 0.0
                trader.close_symbol(sym, price, label="CLOSE_CMD_SYMBOL")
                if app: await notify(app, f"Cierre manual {sym} enviado.")
    save_state(st)

async def loop(app, trader, exchange):
    st = load_state()
    allow_new = bool(st.get("allow_new_entries", True))
    budget = BudgetManager(cfg=RISK)
    # saludo
    if app: await notify(app, f"ü§ñ BESTIA ULTRA online ({MODE})")
    while True:
        try:
            await process_commands(trader, app, exchange)
            for sym in SYMBOLS:
                await trade_symbol(app, trader, exchange, sym, allow_new, budget)
            eq = trader.equity()
            append_csv("data/equity.csv", {"ts": to_iso(now_utc()), "equity": eq, "pnl": 0.0}, header=["ts","equity","pnl"])
            # snapshots
            with open("data/positions.json","w",encoding="utf-8") as f:
                json.dump(trader.snapshot_positions(), f, ensure_ascii=False, indent=2)
            st["allow_new_entries"] = allow_new
            st["updated_at"] = to_iso(now_utc()); save_state(st)
        except Exception as e:
            log_exception(BOT_LOGGER,"Loop error",err=str(e),tb=traceback.format_exc())
            if TELEGRAM_NOTIFY_ERRORS and app:
                await notify(app,f"‚ùå Error loop: {e}")
        await asyncio.sleep(LOOP_SECONDS)

def run():
    exchange = build_exchange()
    paper = PaperExchange(taker_fee=float(FEES.get("taker",0.0005)), maker_fee=float(FEES.get("maker",0.0002)),
                          latency_ms=int(ORDER.get("latency_ms_sim",150)))
    trader = Trader(paper)
    app = build_app()
# === PTB v20 START BLOCK ===
try:
    if app:
        await app.initialize()
        await app.start()
        if getattr(app, "updater", None):
            await app.updater.start_polling()
except Exception as e:
    try:
        log_exception("telegram_startup_error", str(e))
    except Exception:
        pass
    app = None
# === PTB v20 START BLOCK END ===

    async def _main():
        if app:
# removed leftover invalid line
            task_loop = asyncio.create_task(loop(app, trader, exchange))
            await asyncio.gather(task_bot, task_loop)
        else:
            await loop(None, trader, exchange)

    asyncio.run(_main())
